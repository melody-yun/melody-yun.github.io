[{"title":"test","date":"2017-05-11T12:46:08.000Z","path":"2017/05/11/test/","text":"","tags":[]},{"title":"浮动和清除浮动","date":"2016-12-09T01:29:04.000Z","path":"2016/12/09/浮动和清除浮动/","text":"浮动 在我看来浮动元素都是脱离了躯壳的灵魂，有其神而无其形(没有高度)，他们存在于世间，但世人却无法看见他们（脱离文档流，块级元素可占据他们的位置），但是风雨等大自然因素却可以洞察到他们的存在，从而环绕其周围（不脱离文本流，内联元素可环绕在其周围）。 浮动元素的外边距不会合并 浮动非替换元素时必须设定宽度 浮动元素会脱离文档流但不会脱离文本流，因而会造成文本环绕效果，而这也是浮动的本意。 不管是块级元素还是内联元素，一旦浮动就会变成行内块元素（即display: inline-block;） 如果浮动元素应用了负外边距而导致其与相邻元素重叠，分两种情况： 行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素之上显示 块框与一个浮动元素重叠时，其边框和背景都在该浮动元素之下显示，而内容在浮动元素之上显示 清除浮动 上面提到过浮动元素是不具备高度的，因此会造成父元素高度塌陷，可以通过以下方法来清除浮动。不仅要知道什么方式可以清除浮动，更要知道这些方法是如何清除浮动的。 浮动父元素CSS 2.1中提到了浮动的一个特性：浮动元素会延伸，从而包含其所有后代元素。但这有点拆了东墙补西墙的意味，不推荐。应用对象：父元素 overflow属性overflow 属性本意是规定了当内容溢出元素框时发生的事情。但当其属性值为hidden或auto时，它会自动的清理包含的任何浮动元素，也就意味着它是认可浮动元素的高度的。但在某些情况下，使用该方法会产生滚动条或截断内容。所以使用时需谨慎。应用对象：父元素 clear属性clear属性会给该元素添加足够的外边距，从而达到清除浮动的效果。clear 属性的值可以是：left、right、both或none。应用对象：相邻元素 伪元素在没有现成元素可以应用clear属性时，我们可以使用伪元素：1234567 .clearfix::after &#123; content: ''; display: block; visibility: hidden; height: 0; clear: both;&#125; 注：after 会在元素内容后面而不是元素后面插入一个伪元素。 应用对象：父元素 空元素当然，我们也可以直接在浮动元素后面添加一个空元素，如下：1&lt;div style=\"clear:both;\"&gt;&lt;/div&gt; 同样可以达到清除浮动的效果，但会增加不必要的代码，不推荐。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://melody-yun.github.io/tags/CSS/"}]},{"title":"《CSS揭秘》读书笔记一","date":"2016-12-06T07:03:50.000Z","path":"2016/12/06/《CSS揭秘》读书笔记一/","text":"半透明背景 关键在于通过background-clip属性来调整背景的默认行为 12345678910div &#123; border: 10px solid hsla(0, 70%, 10%, 0.5); border-radius: 4px; background-color: white; background-clip: padding-box; max-width: 20rem; padding: 2rem; margin: 2rem auto;&#125; 思考：也可以用box-shadow来实现，优点是可以圆角贴合。123456789div &#123; border-radius: 4px; background-color: white; box-shadow: 0 0 0 10px hsla(0, 70%, 10%, 0.5); max-width: 20rem; padding: 2rem; margin: 2rem auto;&#125; 尝试一下 多重边框 box-shadow可层层叠加，达到多层边框的效果。但它不会影响布局，不会受到box-sizing属性的影响，也不会响应鼠标事件，比如悬停或点击。上述问题可通过增加内外边距和inset来解决。 outline只适用于双层“边框”的场景，且边框不一定会贴合border-radius属性产生的圆角。其优点在于样式灵活(dashed等)，间距可控(outline-offset)。 12345678910111213div &#123; width: 100px; height: 60px; margin: 25px; background: #9ACD32; box-shadow: 0 0 0 10px #655, 0 0 0 15px #FF1493, 0 2px 5px 15px rgba(0, 0, 0, .7); outline: white dashed 1px; outline-offset: -10px;&#125; 尝试一下 灵活的背景位置 background-position默认是padding box。如果想要让它自动地跟着我们设定的内边距走，可以用background-origin: content-box;来解决。图片位置也可以使用calc()来定位。在calc()函数内部的-和+运算符的两侧需各加一个空白符。 123456789.box &#123; /*styling*/ max-width: 10em; min-height: 5em; padding: 10px; margin-bottom: 20px; color: white; font: 100%/1 sans-serif;&#125; 12345.box1 &#123; background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a; background-position: right 20px bottom 10px;&#125; 尝试一下12345.box2 &#123; background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a; background-origin: content-box;&#125; 尝试一下12345.box3 &#123; background: url(http://csssecrets.io/images/code-pirate.svg) no-repeat bottom right #58a; background-position: calc(100% - 20px) calc(100% - 10px);&#125; 尝试一下 区分：background-origin规定背景位置（background-position）的起始点，默认值为padding-box；而background-clip规定背景（图片和背景色）的绘制区域，即裁剪掉区域外的内容，默认值为border-box。可选值图示： 边框内圆角 方法一：用两个div；方法二：用box-shadow填补border和outline之间的空缺，其值需小于描边宽度（等于时会渲染异常），大于\\\\ (\\sqrt{2}*r-r \\)。 1234567891011div &#123; outline: .6em solid #655; box-shadow: 0 0 0 .4em #655; /* 阴影尺寸可选圆角值的一半 */ max-width: 10em; border-radius: .8em; padding: 1em; margin: 1em; background: tan; font: 100%/1.5 sans-serif;&#125; 计算图示：尝试一下 条纹背景 关键在于渐变色标重合 以下代码可以生成三色水平条纹：12345div &#123; background: linear-gradient(#fb3 33.3%, #58a 0, #58a 66.6%, yellowgreen 0); background-size: 100% 45px;&#125; 尝试一下备注：如果我们把第二个色标的位置值设置为0，那它的位置就总是会被浏览器调整为前一个色标的位置值。垂直条纹：12345div&#123; background: linear-gradient(to right, /* 或 90deg */ #fb3 50%, #58a 0); background-size: 30px 100%;&#125; 尝试一下","tags":[{"name":"CSS","slug":"CSS","permalink":"http://melody-yun.github.io/tags/CSS/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://melody-yun.github.io/tags/读书笔记/"}]}]